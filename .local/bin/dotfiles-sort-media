#!/usr/bin/env bash
# Sort pictures and videos into directories based on date taken metadata
# Usage: dotfiles-sort-pics [OPTIONS] <input-dir> <output-dir>

set -euo pipefail

# Configuration
MOVE_FILES=true
DRY_RUN=false

# Counters
PROCESSED=0
SKIPPED=0
DUPLICATES=0
ERRORS=0

# Media extensions to process (images and videos)
MEDIA_EXTENSIONS=(
    # Images
    "jpg" "jpeg" "png" "heic" "gif" "tiff" "tif"
    "bmp" "webp" "raw" "cr2" "nef" "arw" "dng"
    # Videos
    "mov" "mp4" "avi" "mkv" "m4v" "wmv" "flv"
    "webm" "3gp" "mts" "m2ts"
)

# Month name lookup (using string keys to avoid octal interpretation)
get_month_name() {
    case "$1" in
        01) echo "Jan" ;;
        02) echo "Feb" ;;
        03) echo "Mar" ;;
        04) echo "Apr" ;;
        05) echo "May" ;;
        06) echo "Jun" ;;
        07) echo "Jul" ;;
        08) echo "Aug" ;;
        09) echo "Sep" ;;
        10) echo "Oct" ;;
        11) echo "Nov" ;;
        12) echo "Dec" ;;
        *)  echo "Unknown" ;;
    esac
}

usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTIONS] <input-dir> <output-dir>

Sort pictures and videos into directories based on date taken metadata.
Output structure: <year>/<month>-<Mon>/<YYYY-MM-DD>/

Options:
  --copy      Copy files instead of moving (default: move)
  --dry-run   Show what would be done without making changes
  --help      Show this help message

Examples:
  $(basename "$0") ~/Pictures/Unsorted ~/Pictures/Sorted
  $(basename "$0") --dry-run ~/Downloads ~/Pictures
  $(basename "$0") --copy /Volumes/Camera ~/Pictures
EOF
    exit 0
}

log_info() {
    echo "[INFO] $*"
}

log_warn() {
    echo "[WARN] $*" >&2
}

log_error() {
    echo "[ERROR] $*" >&2
}

# Get the date from media metadata or fall back to file creation time
# Returns date in YYYY-MM-DD format
get_media_date() {
    local file="$1"
    local date=""

    # Try DateTimeOriginal first (when photo/video was taken)
    date=$(exiftool -s3 -d "%Y-%m-%d" -DateTimeOriginal "$file" 2>/dev/null | head -1)
    
    if [[ -z "$date" ]]; then
        # Try CreateDate (camera's date)
        date=$(exiftool -s3 -d "%Y-%m-%d" -CreateDate "$file" 2>/dev/null | head -1)
    fi
    
    if [[ -z "$date" ]]; then
        # Try MediaCreateDate (common in video files)
        date=$(exiftool -s3 -d "%Y-%m-%d" -MediaCreateDate "$file" 2>/dev/null | head -1)
    fi
    
    if [[ -z "$date" ]]; then
        # Try ModifyDate
        date=$(exiftool -s3 -d "%Y-%m-%d" -ModifyDate "$file" 2>/dev/null | head -1)
    fi
    
    if [[ -z "$date" ]]; then
        # Fall back to earlier of file birth time or modification time (macOS)
        local birth_date mod_date
        birth_date=$(stat -f "%SB" -t "%Y-%m-%d" "$file" 2>/dev/null)
        mod_date=$(stat -f "%Sm" -t "%Y-%m-%d" "$file" 2>/dev/null)
        
        if [[ -n "$birth_date" && -n "$mod_date" ]]; then
            # Compare dates and use the earlier one
            if [[ "$birth_date" < "$mod_date" ]]; then
                date="$birth_date"
            else
                date="$mod_date"
            fi
        elif [[ -n "$birth_date" ]]; then
            date="$birth_date"
        elif [[ -n "$mod_date" ]]; then
            date="$mod_date"
        fi
    fi
    
    echo "$date"
}

# Check if two files are identical (same size and content)
# Returns 0 if identical, 1 if different
files_are_identical() {
    local file1="$1"
    local file2="$2"
    
    # First check: compare file sizes (fast)
    local size1 size2
    size1=$(stat -f "%z" "$file1" 2>/dev/null)
    size2=$(stat -f "%z" "$file2" 2>/dev/null)
    
    if [[ "$size1" != "$size2" ]]; then
        return 1  # Different sizes, not identical
    fi
    
    # Second check: compare MD5 hashes (slower but definitive)
    local hash1 hash2
    hash1=$(md5 -q "$file1" 2>/dev/null)
    hash2=$(md5 -q "$file2" 2>/dev/null)
    
    if [[ "$hash1" == "$hash2" ]]; then
        return 0  # Identical
    else
        return 1  # Different
    fi
}

# Get a unique filename if destination already exists
# Appends _1, _2, etc. before the extension
get_unique_filename() {
    local dest_dir="$1"
    local filename="$2"
    
    local base="${filename%.*}"
    local ext="${filename##*.}"
    local dest_path="$dest_dir/$filename"
    local counter=1
    
    # If no extension, handle it
    if [[ "$base" == "$ext" ]]; then
        ext=""
    fi
    
    while [[ -e "$dest_path" ]]; do
        if [[ -n "$ext" ]]; then
            dest_path="$dest_dir/${base}_${counter}.${ext}"
        else
            dest_path="$dest_dir/${base}_${counter}"
        fi
        ((counter++))
    done
    
    echo "$dest_path"
}

# Build the destination directory path from a date
# Input: YYYY-MM-DD
# Output: <output-dir>/YYYY/MM-Mon/YYYY-MM-DD
build_dest_path() {
    local output_dir="$1"
    local date="$2"
    
    local year="${date:0:4}"
    local month="${date:5:2}"
    local month_name
    month_name=$(get_month_name "$month")
    
    echo "$output_dir/$year/$month-$month_name/$date"
}

# Build find command arguments for media extensions
build_find_args() {
    local args=()
    local first=true
    
    for ext in "${MEDIA_EXTENSIONS[@]}"; do
        if $first; then
            args+=("(" "-iname" "*.$ext")
            first=false
        else
            args+=("-o" "-iname" "*.$ext")
        fi
    done
    args+=(")")
    
    echo "${args[@]}"
}

# Process a single media file
process_media() {
    local file="$1"
    local output_dir="$2"
    local filename
    filename=$(basename "$file")
    
    # Get date from metadata
    local date
    date=$(get_media_date "$file")
    
    if [[ -z "$date" ]]; then
        log_warn "Could not determine date for: $file"
        ((SKIPPED++)) || true
        return
    fi
    
    # Build destination path
    local dest_dir
    dest_dir=$(build_dest_path "$output_dir" "$date")
    
    # Check for duplicates and get unique filename if needed
    local dest_path="$dest_dir/$filename"
    local is_duplicate=false
    
    if [[ -e "$dest_path" ]]; then
        # File with same name exists - check if it's a duplicate
        if files_are_identical "$file" "$dest_path"; then
            is_duplicate=true
        else
            # Not a duplicate, find unique filename
            if ! $DRY_RUN; then
                dest_path=$(get_unique_filename "$dest_dir" "$filename")
            else
                dest_path="$dest_dir/${filename%.*}_N.${filename##*.}"
            fi
        fi
    fi
    
    # Handle duplicate
    if $is_duplicate; then
        log_info "Skipped (duplicate): $file -> $dest_path"
        ((DUPLICATES++)) || true
        return
    fi
    
    # Perform the operation
    local action
    if $MOVE_FILES; then
        action="Move"
    else
        action="Copy"
    fi
    
    if $DRY_RUN; then
        log_info "[DRY-RUN] $action: $file -> $dest_path"
    else
        # Create destination directory
        mkdir -p "$dest_dir"
        
        # Copy or move the file
        if $MOVE_FILES; then
            if mv -n "$file" "$dest_path"; then
                log_info "Moved: $file -> $dest_path"
                ((PROCESSED++)) || true
            else
                log_error "Failed to move: $file"
                ((ERRORS++)) || true
            fi
        else
            if cp -n "$file" "$dest_path"; then
                log_info "Copied: $file -> $dest_path"
                ((PROCESSED++)) || true
            else
                log_error "Failed to copy: $file"
                ((ERRORS++)) || true
            fi
        fi
    fi
}

# Main function
main() {
    local input_dir=""
    local output_dir=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --copy)
                MOVE_FILES=false
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --help|-h)
                usage
                ;;
            -*)
                log_error "Unknown option: $1"
                echo "Use --help for usage information."
                exit 1
                ;;
            *)
                if [[ -z "$input_dir" ]]; then
                    input_dir="$1"
                elif [[ -z "$output_dir" ]]; then
                    output_dir="$1"
                else
                    log_error "Too many arguments"
                    echo "Use --help for usage information."
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    # Validate arguments
    if [[ -z "$input_dir" ]] || [[ -z "$output_dir" ]]; then
        log_error "Both input and output directories are required"
        echo "Use --help for usage information."
        exit 1
    fi
    
    # Resolve to absolute paths
    input_dir=$(cd "$input_dir" 2>/dev/null && pwd)
    if [[ -z "$input_dir" ]]; then
        log_error "Input directory does not exist: $1"
        exit 1
    fi
    
    # Check input directory exists
    if [[ ! -d "$input_dir" ]]; then
        log_error "Input directory does not exist: $input_dir"
        exit 1
    fi
    
    # Create output directory if needed (unless dry-run)
    if ! $DRY_RUN; then
        mkdir -p "$output_dir"
    fi
    output_dir=$(cd "$output_dir" 2>/dev/null && pwd) || output_dir="$output_dir"
    
    # Check exiftool is available
    if ! command -v exiftool &>/dev/null; then
        log_error "exiftool is not installed. Please install it first."
        echo "  macOS: brew install exiftool"
        echo "  Ubuntu: sudo apt install libimage-exiftool-perl"
        exit 1
    fi
    
    # Print configuration
    echo "============================================"
    echo "Media Sorting Script"
    echo "============================================"
    echo "Input directory:  $input_dir"
    echo "Output directory: $output_dir"
    echo "Mode:             $(if $MOVE_FILES; then echo 'Move'; else echo 'Copy'; fi)"
    if $DRY_RUN; then
        echo "*** DRY RUN - No changes will be made ***"
    fi
    echo "============================================"
    echo ""
    
    # Find and process media files
    # Build the find command dynamically
    local find_cmd="find \"$input_dir\" -type f ! -name \".*\""
    
    # Add extension filters
    local ext_filter="\\( "
    local first=true
    for ext in "${MEDIA_EXTENSIONS[@]}"; do
        if $first; then
            ext_filter+="-iname \"*.$ext\""
            first=false
        else
            ext_filter+=" -o -iname \"*.$ext\""
        fi
    done
    ext_filter+=" \\)"
    
    find_cmd+=" $ext_filter"
    
    # Process each file
    while IFS= read -r file; do
        process_media "$file" "$output_dir"
    done < <(eval "$find_cmd" 2>/dev/null || true)
    
    # Print summary
    echo ""
    echo "============================================"
    echo "Summary"
    echo "============================================"
    if $DRY_RUN; then
        echo "Files that would be processed: $((PROCESSED + SKIPPED + DUPLICATES + ERRORS))"
    else
        echo "Files processed: $PROCESSED"
    fi
    echo "Files skipped (duplicates): $DUPLICATES"
    echo "Files skipped (no date): $SKIPPED"
    echo "Errors: $ERRORS"
    echo "============================================"
}

# Run main function
main "$@"
